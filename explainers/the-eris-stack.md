---

layout: docs
title: "Tutorials | The Eris Stack Explained"

---

The eris stack has undergone many changes in the past 8 months. When I joined in July, the old stack was just about deprecated, docker had recently been embraced full tilt, and our blockchain orchestration tool was a couple months away from the 0.10.0 release. While making incremental contributions to eris-cli and fighting docker, I was also learning to stitch together our various tools natively. The process, albeit daunting (compared, say, to building a simple web app), is fairly straightforward once layed out clearly. 

This post is intended to provide a high level overview and a detailed explanation of how the eris stack is, well, stacked. [Modularity is a strong focus](https://eng.erisindustries.com/tutorials/2015/09/05/docker-and-eris/), greatly facilitated by [docker](https://docker.com). I'll be focusing on how the tools fit together while painting a path through the tutorial series. The complicated task of orchestrating all the various requirements for a smart-contract-focused blockchain is exactly why we went all-in on docker despite various ongoing pain points. We like to think of [eris:cli](https://docs.erisindustries.com/documentation/eris/) as "docker for blockchains".

{% image eris-stack-v2.png %}

Let's get started! The above diagram shows the relationship between most of the tools in the eris stack. Before docker, each had to be installed individually. Docker also provides the ability to seamlessly link the running containers, so that the individual processes can talk to each other. When deploying many nodes, this is known as service discovery and greatly facilitates large-scale deployments. There are several considerations for thinking about the mechanics of your chain as an application. The first three suffice if your goal is writing and testing smart contracts. The rest are for building a useable application at scale.

## Blockchain Checklist

1) It all starts with your keys. This is crypto, remember? Key management is an inherently complex process and is something that should be given serious thought. It's getting easier overall (e.g. keybase), but at the moment there remain caveats. A key needs to be generated and secured for each participant in your blockchain. Can't do much on a blockchain without a validator or participant who can't sign transactions. This is a fundamentally different approach for web services compared to login/password. If you're gonna be blockchaining, do try to really understand how keys work and are used. Our key signing daemon [eris:keys](https://docs.erisindustries.com/documentation/ekeys/), usually run in a docker container, provides the basic functionality for getting started with development. 

As with all the tools in our stack, it can easily be swapped out for other compatible key signing daemons. In fact, it **must be swapped out** for production use cases. It is for **development only** and we do not yet offer an enterprise key management solution. However the common keys API can either be satisfied by your audited security system of choice or we will be looking to provide proxy based access to various security and key management systems over time.

2) Roll a chain. Blockchains have a few key properties: validators (specified in the all important genesis file or updated on the fly with bond transactions), a consensus engine (the mechanism for updating state), and a virtual machine (for executing smart contracts). Our current design is opinated and uses the [Tendermint](https://github.com/tendermint/tendermint/wiki) consensus engine and a fork of the [Ethereum Virtual Machine](https://github.com/ethereum/wiki/wiki/White-Paper). Both the consensus engine and virtual machine are, again, modules that can be swapped in and out as need by. Currently, they are packaged together as [eris:db](https://docs.erisindustries.com/documentation/edb/). The docker image used to run eris:db also contains [mint-client](https://github.com/eris-ltd/mint-client), a low-level tool for talking to tendermint. A low-level [eth-client](https://github.com/eris-ltd/eth-client) is also available if you'd rather be rolling an ethereum chain.

To create genesis files and keys for development, we have the [eris chain maker](https://github.com/eris-ltd/eris-cm). The chain maker supports a wide variety of chain types, permissioning schemes, and participant kinds.

**Note:** We are currently in the process of refactoring the codebase towards the described modular approach. For the time being, eris:db uses Tendermint consensus. See Ethan's post [On Application and Consensus](https://eng.erisindustries.com/explainers/2016/02/22/apps-and-consensus/) for more details on the underlying technical rationale and [the diffence between tendermint and eris](https://blog.erisindustries.com/philosophy/2016/03/02/eris-and-tendermint/) for how it all came to be. A sample example of eris:db <= [tmsp](https://github.com/tendermint/tmsp) => tendermint consensus is available [here](https://github.com/eris-ltd/eris-by-example/tree/master/erisdb_tmsp).

3) Deploy contracts: write solidity, compile, send to the chain. We provide hosted compilers which uses the [lllc-server](https://github.com/eris-ltd/eris-compilers), and as you would expect, swapping in your own compiler is as easy as flag with [eris:pm](https://erisindustries.com/components/epm/), our contract deployement tool which simplifies a handful of steps (see the diagram). The [eris:abi](https://github.com/eris-ltd/eris-abi) is used for formatting compiled solidity code. Most, if not all, of these steps are abstracted away with the `eris pkgs do` command. See the [contracts deploying tutorial](https://docs.erisindustries.com/tutorials/contractsdeploying/) for more information.

4) Write you app (Dapp). We call them services. A handful are already built for you. Some of services are used internally, for example, [IPFS](http://ipfs.io/), to provide a data lake for applications (the `eris files` command). The [mindy](https://github.com/eris-ltd/mindy) [testnet](pinkpenguin.interblock.io:46657) has been running for many months now and works fairly well for sub-domain name registry. The [toadserver](https://github.com/eris-ltd/toadserver) integrates each mindy, IPFS, and eris:db's name registry feature to serve as a download server. [This will soon](https://github.com/eris-ltd/eris-cli/issues/579) replace github as part of the `eris init` sequence. I recently built the [marmot checker](https://github.com/eris-ltd/marmot) which integrates the Google Cloud Vision API with the toadserver. Eris services are built to support modern, containerized, microservices style applications out of the box. 

5) Deploy to the cloud. This process uses [docker-machine](https://docs.erisindustries.com/tutorials//tool-specific/docker_machine/) and will soon be bundled up in the `eris remotes` command to simplify the process even further. See the [advanced cloud tutorial](https://docs.erisindustries.com/tutorials/advanced/chaindeploying/) for more information on deploying your chain to the cloud.

Voila! Your app is ready for users. Of course, you'll want to build a user interface, likely at the javascript layer. To simplify that process, we have three javasript libraries: [eris:db.js](https://docs.erisindustries.com/documentation/eris-db-js/),  [eris:contracts.js](https://docs.erisindustries.com/documentation/eris-contracts-js/), and [eris:keys.js](https://github.com/eris-ltd/eris-keys.js)

Above, I've highlighted the relevant repositories and some tutorials currently maintained as part of the Eris stack. So where should you even start? Next, we'll walk through one approach - the one I consider most intuitive for thinking about the design of you chain/application - though in practice you can probably start anywhere. This is how I do it when testing or implementing the toadserver/marmot checker.

## The development lifecycle

We start with the genesis file. The sets up your chain and contains approved validators, their initial coin distribution, any permissions, roles, or names can be assigned to them. Maybe you want 5, maybe you want 100. See [the advanced chain making tutorial](https://docs.erisindustries.com/tutorials/advanced/chainmaking/) for more info on creating chains. Since you'll need the public keys of everyone you'd like included, a key pair will need to be generated for each participant/validator. Either you do this all yourself and distribute the keys or ask each user to generate a pair themselves and provide the pubkey. For the latter, you'd pass in a `.csv` file on the `eris chains make --known` command. You could also try the [Blocklab](http://blocklab.levvel.io/) tool. Each have pros and cons that need to be carefully thought through. At any rate, it is always possible to update the validator set with a bond/unbond transaction, or, if they misbehave, their security deposit (bond) can be slashed: validator they are no longer. (More details in a future post).

It's time to start bringing nodes online. The first node starts up and peers can join like so: a seed of the master node's IP:port is added to their configuration file (`config.toml`) used in the `eris chains new` sequence. So long as the peer coming online has a key that 1) can sign (via the keys daemon) and 2) is included in the genesis file, then it'll join the network. Once >2/3 of known validators join, the chain will begin validating transactions (i.e., updating state, "mining", producing blocks etc). If the chain drops below 2/3 validators, it will halt. The status and health of a chain can be monitored easily through various means such as the `mintinfo` command from mint-client, the js library (port 1337), or pure http endpoints (port 46657). The chains command for eris-cli is designed to handle all operations for one or more chains. With your chain running, you can send transactions (`mintx send`) and deploy contracts using eris:pm. At the tool level, these would primarily be used by chain admins whereas developers for a user-facing application would likely be working at the javascript layer for sending transactions and deploying contracts. More info: [chain deploying](https://docs.erisindustries.com/tutorials/advanced/chaindeploying/); [contracts interacting](https://docs.erisindustries.com/tutorials/contractsinteracting/); and [collaborating on your application](https://docs.erisindustries.com/tutorials/servicesmaking/).

Now you need an application. Before we get into some design considerations for an app, let's dissect the process of sending transactions and deploying contracts. At the end of the day, the latter is the former but includes compiled byte code as part of the transaction (see eris-abi in the diagram). The specific requirements for sending a transaction are documented [here](https://github.com/eris-ltd/mint-client/blob/master/README.md#walkabout). Provided these are met, the mintx command will first craft a transaction and, if specified, sign and broadcast it to the designated chain. Again, since the key signing that transaction must be available to the daemon, docker simplifies this logitics challenge. So that's pretty easy but it's no bitcoin wallet in terms of simplicity. 

Now let's deploy a contract. For writing smart contracts, see [Andreas' tutorial series](https://docs.erisindustries.com/tutorials/solidity/). Ok, you've got a simple contract and would like to deploy it. The first step takes the solidity code and compiles it into bytecode. This bytecode will be used as the raw input for `mintx send` of the contracts you're deploying. After the transaction is crafted, the abi formats this bytecode into something that the EVM can read/interpret. Now your contract is on the chain and can be called with `mintx call` or via the [javascript library](https://docs.erisindustries.com/documentation/eris-contracts-js/). This process of: solidity -> lllc-server -> mintx -> abi -> sign -> deploy is wholly abstracted away by eris:pm; see the [contract deploying tutorial](https://docs.erisindustries.com/tutorials/contractsinteracting/) for more info. In essence, you write a contract, specify a few parameters in a `.yaml` file then vrooom `eris pkgs do`.

So a transaction hits the chain, then what? Roughly, the transaction will be proposed and the validators will vote on whether or not to accept it in the next block. Voting happens in a round robin manner. In the aforementioned refactor, tendermint the consensus engine will be its own module which talks to the eris:db application layer over the  [tendermint socket protocol (tmsp)](http://tendermint.com/posts/tendermint-socket-protocol/), This will make experimentation with other consensus engines much simpler (Casper anyone?). Indeed, it is already possible to roll an eth chain and talk to it with the [eth-client](https://github.com/eris-ltd/eth-client). So we've got three ways to deploy contracts and send transactions, 1) raw RPC commands 2) with eris:pm and, 3) the javascript library (eris-db.js). The way in which certain contracts are deployed and by whom at these different levels should be considered for you application.

Time to build your service (app). But wait. What is eris-cli anyways, and why would you want to use it? How will help it operate your blockchain application? As previously mentioned, it's an orchestration tool. Everything we've discussed so far can be done natively (i.e., without docker); this requires stitching together the various tools (see, for example, [eris by curl](https://docs.erisindustries.com/tutorials/tool-specific/eris_by_curl/). eris:cli makes it easier to co-ordinate all the things you need to roll a smart-contract ready chain with an application. With that in mind, our goal now is to build and define a service that, when started, links up to the existing chain and any other services that are required for the application to run smoothly. Once your service is built (write a bunch of code, basically), all it needs is a service definition file (`eris services new`; see the specification [here](https://docs.erisindustries.com/documentation/eris-cli/latest/services_specification/) which simplifies the `docker run` process. This of course assumes you've written a [Dockerfile](https://docs.docker.com/engine/reference/builder/) and made a [docker image](https://docs.docker.com/engine/userguide/containers/dockerimages/). See the [toadserver service making tutorial](https://docs.erisindustries.com/tutorials/advanced/servicesmaking/) for more information on this process.

The last tricky part, now that we have a defined service, is to deploy it to the cloud with >1 node/validator. Here again, docker shines, this time as a machine. The eris tool has a global flag `--machine` which can be used to specify another docker daemon (on any number of other hosts) upon which to execute a command. Note: these docker machines will have been pre-created using your choice of cloud provider. See the [Eris <=> docker-machine tutorial](https://docs.erisindustries.com/tutorials//tool-specific/docker_machine/) for more information. The beauty of this feature is that the files needed for these deployments need only be on the host, and, of course, you only need install eris once. 

There you have it. From A to Blockchains, this is how you get rolling with the marmots. Want a tutorial that we haven't provided? [Make an issue in our documentation repository!](https://github.com/eris-ltd/docs.erisindustries.com/issues)
